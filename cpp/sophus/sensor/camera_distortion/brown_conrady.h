// Copyright (c) 2011, Hauke Strasdat
// Copyright (c) 2012, Steven Lovegrove
// Copyright (c) 2021, farm-ng, inc.
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file or at
// https://opensource.org/licenses/MIT.

#pragma once

#include "sophus/ceres/jet_helpers.h"
#include "sophus/common/common.h"
#include "sophus/sensor/camera_distortion/affine.h"

#include <Eigen/Dense>

namespace sophus {
class BrownConradyTransform {
 public:
  static int constexpr kNumDistortionParams = 8;
  static int constexpr kNumParams = kNumDistortionParams + 4;
  static constexpr const std::string_view kProjectionModel =
      "BrownConrady: fx, fy, cx, cy, k1, k2, p1, p2, k3, k4, k5, k6";

  template <class TScalar>
  using ProjInCameraZ1Plane = Eigen::Matrix<TScalar, 2, 1>;
  template <class TScalar>
  using PixelImage = Eigen::Matrix<TScalar, 2, 1>;
  template <class TScalar>
  using Params = Eigen::Matrix<TScalar, kNumParams, 1>;
  template <class TScalar>
  using DistorationParams = Eigen::Matrix<TScalar, kNumDistortionParams, 1>;

  template <class TParamScalarT, class TPointScalarT>
  static PixelImage<typename Eigen::ScalarBinaryOpTraits<
      TParamScalarT,
      TPointScalarT>::ReturnType>
  projImpl(
      DistorationParams<TParamScalarT> const& distortion,
      PixelImage<TPointScalarT> const& point_normalized) {
    using ReturnScalar = typename Eigen::
        ScalarBinaryOpTraits<TParamScalarT, TPointScalarT>::ReturnType;

    // aliases to match opencv's implementation
    auto x = point_normalized[0];
    auto y = point_normalized[1];
    auto const& k = distortion;

    // From:
    // https://github.com/opencv/opencv/blob/63bb2abadab875fc648a572faccafee134f06fc8/modules/calib3d/src/calibration.cpp#L791

    auto r2 = x * x + y * y;
    auto r4 = r2 * r2;
    auto r6 = r4 * r2;
    auto a1 = 2 * x * y;
    auto a2 = r2 + 2 * x * x;
    auto a3 = r2 + 2 * y * y;
    auto cdist = 1 + k[0] * r2 + k[1] * r4 + k[4] * r6;
    auto icdist2 = 1. / (1 + k[5] * r2 + k[6] * r4 + k[7] * r6);
    auto xd0 = x * cdist * icdist2 + k[2] * a1 + k[3] * a2;
    auto yd0 = y * cdist * icdist2 + k[2] * a3 + k[3] * a1;

    return PixelImage<ReturnScalar>(xd0, yd0);
  }

  template <class TScalar>
  static PixelImage<TScalar> unprojImpl(
      DistorationParams<TScalar> const& distortion,
      PixelImage<TScalar> const& uv_normalized) {
    // We had no luck with OpenCV's undistort. It seems not to be accurate if
    // "icdist" is close to 0.
    // https://github.com/opencv/opencv/blob/63bb2abadab875fc648a572faccafee134f06fc8/modules/calib3d/src/undistort.dispatch.cpp#L365
    //
    // Hence, we derive the inverse approximation scheme from scratch.
    //
    //
    // Objective: find that xy such that proj_impl(xy) = uv
    //
    // Using multivariate Newton scheme, by defining f and find the root of it:
    //
    //  f: R^2 -> R^2
    //  f(xy) :=  proj_impl(xy) - uv
    //
    //  xy_i+1 = xy_i + J^{-1} * f(xy)   with J being the Jacobian of f.
    //
    // TODO(hauke): There is most likely a 1-dimensional embedding and one only
    // need to solve a less computational heavy newton iteration...

    // initial guess
    PixelImage<TScalar> xy = uv_normalized;

    TScalar p0 = distortion[0];
    TScalar p1 = distortion[1];
    TScalar p2 = distortion[2];
    TScalar p3 = distortion[3];
    TScalar p4 = distortion[4];

    for (int i = 0; i < 50; ++i) {
      TScalar x = xy[0];
      TScalar y = xy[1];
      TScalar x2 = x * x;
      TScalar y2 = y * y;
      TScalar r2 = x2 + y2;
      TScalar r4 = r2 * r2;
      TScalar r6 = r2 * r4;

      PixelImage<TScalar> f_xy =
          projImpl(distortion, Eigen::Matrix<TScalar, 2, 1>(x, y)) -
          uv_normalized;

      TScalar du_dx;
      TScalar du_dy;
      TScalar dv_dx;
      TScalar dv_dy;

      {
        // Generated by brown_conrady_camera.py
        TScalar const a = x;
        TScalar const b = y;
        DistorationParams<TScalar> const& d = distortion;

        TScalar const c0 = a * a;  // pow(a, 2);
        TScalar const c1 = b * b;  // pow(b, 2);
        TScalar const c2 = c0 + c1;
        TScalar const c3 = c2 * c2;  // pow(c2, 2);
        TScalar const c4 = c3 * c2;  // pow(c2, 3);
        TScalar const c5 = c2 * d[5] + c3 * d[6] + c4 * d[7] + 1.0;
        TScalar const c6 = c5 * c5;  // pow(c5, 2);
        TScalar const c7 = 1.0 / c6;
        TScalar const c8 = a * d[3];
        TScalar const c9 = 2.0 * d[2];
        TScalar const c10 = 2 * c2;
        TScalar const c11 = 3 * c3;
        TScalar const c12 = c2 * d[0];
        TScalar const c13 = c3 * d[1];
        TScalar const c14 = c4 * d[4];
        TScalar const c15 =
            2.0 * (c10 * d[6] + c11 * d[7] + d[5]) * (c12 + c13 + c14 + 1.0);
        TScalar const c16 = 2.0 * c10 * d[1] + 2.0 * c11 * d[4] + 2.0 * d[0];
        TScalar const c17 = 1.0 * c12 + 1.0 * c13 + 1.0 * c14 + 1.0;
        TScalar const c18 = b * d[3];
        TScalar const c19 = a * b;
        TScalar const c20 = -c15 * c19 + c16 * c19 * c5;
        du_dx =
            c7 * (-c0 * c15 + c5 * (c0 * c16 + c17) + c6 * (b * c9 + 6.0 * c8));
        du_dy = c7 * (c20 + c6 * (a * c9 + 2 * c18));
        dv_dx = c7 * (c20 + c6 * (2 * a * d[2] + 2.0 * c18));
        dv_dy = c7 * (-c1 * c15 + c5 * (c1 * c16 + c17) +
                      c6 * (6.0 * b * d[2] + 2.0 * c8));
      }

      //     | du_dx  du_dy |      | a  b |
      // J = |              |  =:  |      |
      //     | dv_dx  dv_dy |      | c  d |

      TScalar a = du_dx;
      TScalar b = du_dy;
      TScalar c = dv_dx;
      TScalar d = dv_dy;

      // | a  b | -1       1   |  d  -b |
      // |      |     =  ----- |        |
      // | c  d |        ad-bc | -c   a |

      Eigen::Matrix<TScalar, 2, 2> m;
      // clang-format off
      m <<  d, -b,
           -c,  a;
      // clang-format on

      Eigen::Matrix<TScalar, 2, 2> j_inv = TScalar(1) / (a * d - b * c) * m;
      PixelImage<TScalar> step = j_inv * f_xy;

      if (abs(jet_helpers::GetValue<TScalar>::impl(step.squaredNorm())) <
          sophus::kEpsilon<TScalar> * sophus::kEpsilon<TScalar>) {
        break;
      }
      xy -= step;
    }

    return xy;
  }

  template <class TParamsTypeT, class TPointTypeT>
  static PixelImage<typename TPointTypeT::Scalar> distort(
      Eigen::MatrixBase<TParamsTypeT> const& params,
      Eigen::MatrixBase<TPointTypeT> const& proj_point_in_camera_z1_plane) {
    using ParamScalar = typename TParamsTypeT::Scalar;

    static_assert(
        TParamsTypeT::ColsAtCompileTime == 1, "params must be a column-vector");
    static_assert(
        TParamsTypeT::RowsAtCompileTime == kNumParams,
        "params must have exactly kNumParams rows");
    static_assert(
        TPointTypeT::ColsAtCompileTime == 1,
        "point_camera must be a column-vector");
    static_assert(
        TPointTypeT::RowsAtCompileTime == 2,
        "point_camera must have exactly 2 columns");

    Eigen::Matrix<ParamScalar, kNumDistortionParams, 1> distortion =
        params.template tail<kNumDistortionParams>();

    PixelImage<typename TPointTypeT::Scalar>
        distorted_point_in_camera_z1_plane =
            projImpl(distortion, proj_point_in_camera_z1_plane.eval());

    return AffineTransform::distort(
        params.template head<4>(), distorted_point_in_camera_z1_plane);
  }

  template <class TScalar>
  static ProjInCameraZ1Plane<TScalar> undistort(
      Params<TScalar> const& params, PixelImage<TScalar> const& pixel_image) {
    PixelImage<TScalar> proj_point_in_camera_z1_plane = unprojImpl(
        params.template tail<kNumDistortionParams>().eval(),
        AffineTransform::undistort(
            params.template head<4>().eval(), pixel_image));

    return ProjInCameraZ1Plane<TScalar>(
        proj_point_in_camera_z1_plane[0], proj_point_in_camera_z1_plane[1]);
  }

  template <class TParamsTypeT, class TPointTypeT>
  static Eigen::Matrix<typename TPointTypeT::Scalar, 2, 2> dxDistort(
      Eigen::MatrixBase<TParamsTypeT> const& params,
      Eigen::MatrixBase<TPointTypeT> const& proj_point_in_camera_z1_plane) {
    static_assert(
        TParamsTypeT::ColsAtCompileTime == 1, "params must be a column-vector");
    static_assert(
        TParamsTypeT::RowsAtCompileTime == kNumParams,
        "params must have exactly kNumParams rows");
    static_assert(
        TPointTypeT::ColsAtCompileTime == 1,
        "point_camera must be a column-vector");
    static_assert(
        TPointTypeT::RowsAtCompileTime == 2,
        "point_camera must have exactly 2 columns");
    using Scalar = typename TPointTypeT::Scalar;

    Eigen::Matrix<Scalar, kNumDistortionParams, 1> d =
        params.template tail<kNumDistortionParams>();

    Scalar a = proj_point_in_camera_z1_plane[0];
    Scalar b = proj_point_in_camera_z1_plane[1];

    Eigen::Matrix<typename TPointTypeT::Scalar, 2, 2> dx;
    Scalar const fx = params[0];
    Scalar const fy = params[1];

    // Generated by brown_conrady_camera.py
    Scalar const c0 = a * d[3];
    Scalar const c1 = 2.0 * d[2];
    Scalar const c2 = a * a;  // pow(a, 2);
    Scalar const c3 = b * b;  // pow(b, 2);
    Scalar const c4 = c2 + c3;
    Scalar const c5 = c4 * c4;  // pow(c4, 2);
    Scalar const c6 = c5 * c4;  // pow(c4, 3);
    Scalar const c7 = c4 * d[5] + c5 * d[6] + c6 * d[7] + 1.0;
    Scalar const c8 = c7 * c7;  // pow(c7, 2);
    Scalar const c9 = 2 * c4;
    Scalar const c10 = 3 * c5;
    Scalar const c11 = c4 * d[0];
    Scalar const c12 = c5 * d[1];
    Scalar const c13 = c6 * d[4];
    Scalar const c14 =
        2.0 * (c10 * d[7] + c9 * d[6] + d[5]) * (c11 + c12 + c13 + 1.0);
    Scalar const c15 = 2.0 * c10 * d[4] + 2.0 * c9 * d[1] + 2.0 * d[0];
    Scalar const c16 = 1.0 * c11 + 1.0 * c12 + 1.0 * c13 + 1.0;
    Scalar const c17 = 1.0 / c8;
    Scalar const c18 = c17 * fx;
    Scalar const c19 = b * d[3];
    Scalar const c20 = a * b;
    Scalar const c21 = -c14 * c20 + c15 * c20 * c7;
    Scalar const c22 = c17 * fy;
    dx(0, 0) =
        c18 * (-c14 * c2 + c7 * (c15 * c2 + c16) + c8 * (b * c1 + 6.0 * c0));
    dx(0, 1) = c22 * (c21 + c8 * (2 * a * d[2] + 2.0 * c19));
    dx(1, 0) = c18 * (c21 + c8 * (a * c1 + 2 * c19));
    dx(1, 1) = c22 * (-c14 * c3 + c7 * (c15 * c3 + c16) +
                      c8 * (6.0 * b * d[2] + 2.0 * c0));

    return dx;
  }
};

}  // namespace sophus
